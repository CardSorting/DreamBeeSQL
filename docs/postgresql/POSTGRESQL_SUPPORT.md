# PostgreSQL Support for NOORMME

## Overview

NOORMME now supports PostgreSQL alongside SQLite, providing a unified API for both database systems. This allows you to start with SQLite for rapid prototyping and seamlessly migrate to PostgreSQL when you need production-grade features.

## What Was Added

### 1. PostgreSQL Dialect Implementation

Created a complete PostgreSQL dialect following the same architecture as SQLite:

- **`postgresql-dialect-config.ts`**: Configuration interfaces and types for PostgreSQL
- **`postgresql-driver.ts`**: Connection management and pooling
- **`postgresql-query-compiler.ts`**: SQL query compilation for PostgreSQL syntax
- **`postgresql-adapter.ts`**: Dialect-specific features and migration support
- **`postgresql-introspector.ts`**: Schema introspection for PostgreSQL databases
- **`postgresql-dialect.ts`**: Main dialect class that ties everything together

### 2. Connection Management

PostgreSQL uses connection pooling (via `pg` library) instead of SQLite's single-connection model:

```typescript
const db = new NOORMME({
  dialect: 'postgresql',
  connection: {
    host: 'localhost',
    port: 5432,
    database: 'myapp',
    username: 'postgres',
    password: 'secret',
    ssl: true,
    pool: {
      max: 20,
      min: 5,
      idleTimeoutMillis: 30000,
      connectionTimeoutMillis: 2000,
    }
  }
})
```

### 3. Connection String Support

Both URL formats are supported:

```typescript
// PostgreSQL URLs
new NOORMME('postgresql://user:pass@localhost:5432/mydb')
new NOORMME('postgres://user:pass@localhost:5432/mydb')

// SQLite URLs
new NOORMME('sqlite:./database.sqlite')

// Environment variable
process.env.DATABASE_URL = 'postgresql://...'
new NOORMME() // Automatically reads from DATABASE_URL
```

### 4. PostgreSQL Helper Module

Created `src/helpers/postgresql.ts` with utility functions:

```typescript
import { createPostgresNoormme, PostgresPresets } from 'noormme/helpers/postgresql'

const db = createPostgresNoormme({
  host: 'localhost',
  database: 'myapp',
  user: 'postgres',
  password: 'secret',
  ...PostgresPresets.production
})
```

### 5. Updated Package Dependencies

- Added `pg` (node-postgres) for PostgreSQL connectivity
- Added `@types/pg` for TypeScript type definitions
- Updated package description and keywords to include PostgreSQL

## Key Features

### Unified API

The same repository pattern works for both SQLite and PostgreSQL:

```typescript
// Works with both SQLite and PostgreSQL
const userRepo = db.getRepository('users')
const users = await userRepo.findAll()
const user = await userRepo.findByEmail('john@example.com')
const activeUsers = await userRepo.findManyByStatus('active')
```

### Schema Introspection

PostgreSQL introspector queries `information_schema` and `pg_catalog` to discover:
- Tables and views
- Columns with data types
- Indexes (including unique and primary keys)
- Foreign key constraints
- Schema metadata

### Transaction Support

PostgreSQL supports full ACID transactions with isolation levels:

```typescript
await db.transaction(async (trx) => {
  await trx.getRepository('users').create({ name: 'John' })
  await trx.getRepository('orders').create({ userId: 1, amount: 100 })
}, { isolationLevel: 'serializable' })
```

### Connection Pooling

Automatic connection pooling with configurable settings:
- Min/max pool size
- Idle timeout
- Connection timeout
- SSL support

## Query Compiler Differences

### PostgreSQL-Specific Features

1. **Parameter Placeholders**: Uses `$1`, `$2`, etc. (vs SQLite's `?`)
2. **Auto-increment**: `GENERATED BY DEFAULT AS IDENTITY` (vs SQLite's `AUTOINCREMENT`)
3. **Boolean Values**: Native `true`/`false` (vs SQLite's 0/1)
4. **Identifier Wrapping**: Double quotes `"table"` (same as SQLite)

## Migration Path

### From SQLite to PostgreSQL

1. Export your SQLite schema
2. Create equivalent PostgreSQL tables
3. Update connection config:

```typescript
// Before (SQLite)
const db = new NOORMME({
  dialect: 'sqlite',
  connection: { database: './app.sqlite' }
})

// After (PostgreSQL)
const db = new NOORMME({
  dialect: 'postgresql',
  connection: {
    host: 'localhost',
    port: 5432,
    database: 'app',
    username: 'postgres',
    password: 'secret'
  }
})
```

**Your application code stays the same!** The repository methods and queries work identically.

## Testing PostgreSQL Support

To test PostgreSQL functionality:

1. Install dependencies:
```bash
pnpm install
```

2. Set up a PostgreSQL database:
```bash
createdb test_noormme
```

3. Run tests:
```bash
pnpm test
```

## Examples

### Basic Usage

```typescript
import { NOORMME } from 'noormme'

const db = new NOORMME({
  dialect: 'postgresql',
  connection: {
    host: 'localhost',
    port: 5432,
    database: 'myapp',
    username: 'postgres',
    password: 'secret'
  }
})

await db.initialize()

const users = db.getRepository('users')
const allUsers = await users.findAll()
```

### Production Configuration

```typescript
import { NOORMME } from 'noormme'

const db = new NOORMME({
  dialect: 'postgresql',
  connection: {
    host: process.env.DB_HOST,
    port: parseInt(process.env.DB_PORT || '5432'),
    database: process.env.DB_NAME,
    username: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    ssl: process.env.NODE_ENV === 'production',
    pool: {
      max: 20,
      min: 5,
      idleTimeoutMillis: 30000,
    }
  },
  automation: {
    enableAutoOptimization: true,
    enableIndexRecommendations: true,
  },
  performance: {
    enableCaching: true,
    maxCacheSize: 1000
  }
})

await db.initialize()
```

### Advanced Queries

```typescript
// Complex queries with joins and aggregations
const analytics = await db.getKysely()
  .selectFrom('orders')
  .innerJoin('users', 'users.id', 'orders.user_id')
  .select(({ fn }) => [
    'users.email',
    fn.count('orders.id').as('order_count'),
    fn.sum('orders.amount').as('total_spent'),
    fn.avg('orders.amount').as('avg_order'),
  ])
  .where('orders.created_at', '>=', new Date('2024-01-01'))
  .groupBy('users.id')
  .having(({ fn }) => fn.count('orders.id'), '>', 5)
  .execute()
```

## Architecture

### Dialect Structure

```
src/dialect/postgresql/
├── postgresql-adapter.ts          # Dialect-specific features
├── postgresql-dialect-config.ts   # Configuration types
├── postgresql-dialect.ts          # Main dialect class
├── postgresql-driver.ts           # Connection & pooling
├── postgresql-introspector.ts     # Schema introspection
└── postgresql-query-compiler.ts   # Query compilation
```

### Integration Points

1. **NOORMME Core** (`src/noormme.ts`):
   - `createDialect()`: Factory method for creating PostgreSQL dialect
   - `parseConnectionString()`: Parses PostgreSQL URLs
   - `getDefaultPort()`: Returns 5432 for PostgreSQL

2. **Index** (`src/index.ts`):
   - Exports all PostgreSQL classes and types

3. **Package Exports** (`package.json`):
   - Exports `noormme/helpers/postgresql` module

## Best Practices

### Development

- Use SQLite for local development (faster, simpler)
- Use PostgreSQL for staging/production
- Keep connection configs in environment variables

### Production

- Enable SSL in production environments
- Configure appropriate pool sizes based on load
- Monitor connection usage and adjust pool settings
- Use connection strings for easier configuration management

### Security

- Never commit passwords in code
- Use environment variables or secret management
- Enable SSL for remote connections
- Use read-only users for reporting queries

## PostgreSQL-Specific Features

NOORMME now includes comprehensive support for PostgreSQL-specific features:

### 1. Array Column Types

Support for PostgreSQL array types with helper functions:

```typescript
import { PostgresArrayHelpers } from 'noormme/helpers/postgresql'

// Create table with array columns
await db.kysely.schema
  .createTable('posts')
  .addColumn('id', 'serial', col => col.primaryKey())
  .addColumn('tags', 'text[]')
  .addColumn('scores', 'integer[]')
  .execute()

// Query with array operations
const posts = await db.kysely
  .selectFrom('posts')
  .selectAll()
  .where(PostgresArrayHelpers.contains('tags', ['typescript']))
  .execute()
```

**Supported Array Types**: `text[]`, `integer[]`, `bigint[]`, `boolean[]`, `date[]`, `timestamp[]`, `uuid[]`, `json[]`, `jsonb[]`, and more.

### 2. JSON/JSONB Support

Full support for JSON and JSONB operations:

```typescript
import { PostgresJSONHelpers } from 'noormme/helpers/postgresql'

// Extract JSON fields
const users = await db.kysely
  .selectFrom('users')
  .select(PostgresJSONHelpers.extract('metadata', 'email').as('email'))
  .where(PostgresJSONHelpers.hasKey('metadata', 'email'))
  .execute()

// Update JSON fields
await db.kysely
  .updateTable('users')
  .set({
    metadata: PostgresJSONHelpers.set('metadata', ['address', 'city'], 'New York')
  })
  .execute()
```

### 3. Full-Text Search

Built-in full-text search capabilities:

```typescript
import { PostgresFullTextHelpers } from 'noormme/helpers/postgresql'

// Add generated tsvector column
await PostgresFullTextHelpers.addGeneratedTSVectorColumn(
  db.kysely,
  'articles',
  'search_vector',
  ['title', 'content']
)

// Create GIN index for performance
await PostgresFullTextHelpers.createGINIndex(db.kysely, 'articles', 'search_vector')

// Search with ranking
const results = await db.kysely
  .selectFrom('articles')
  .selectAll()
  .select(PostgresFullTextHelpers.rank('search_vector', 'typescript').as('rank'))
  .where(PostgresFullTextHelpers.match('search_vector', 'typescript'))
  .orderBy('rank', 'desc')
  .execute()
```

### 4. Materialized Views

Materialized view management:

```typescript
import { PostgresMaterializedViewHelpers } from 'noormme/helpers/postgresql'

// Create materialized view
await PostgresMaterializedViewHelpers.create(
  db.kysely,
  'user_stats',
  sql`SELECT user_id, COUNT(*) as post_count FROM posts GROUP BY user_id`
)

// Refresh materialized view
await PostgresMaterializedViewHelpers.refresh(db.kysely, 'user_stats', {
  concurrently: true
})
```

For detailed documentation on PostgreSQL-specific features, see [docs/postgresql-features.md](docs/postgresql-features.md).

## Migration Tools ✅

NOORMME now includes comprehensive migration tools for seamless database transitions:

### Automated Database Migration

```typescript
import { createMigrationManager } from 'noormme/helpers/postgresql'

const sourceDb = new NOORMME('sqlite:./source.sqlite')
const targetDb = new NOORMME('postgresql://user:pass@localhost/target')

await sourceDb.initialize()
await targetDb.initialize()

const migrationManager = createMigrationManager(
  sourceDb.getKysely(),
  targetDb.getKysely(),
  {
    source: {
      dialect: 'sqlite',
      database: './source.sqlite',
    },
    target: {
      dialect: 'postgresql',
      database: 'target',
      host: 'localhost',
      port: 5432,
      username: 'user',
      password: 'pass',
    },
    options: {
      batchSize: 1000,
      parallel: false,
      verbose: true,
    },
  }
)

const result = await migrationManager.migrate()
console.log(`Migrated ${result.rowsMigrated} rows in ${result.duration}ms`)
```

### Schema Diff and Sync

```typescript
import { compareSchemas } from 'noormme/helpers/postgresql'

// Compare schemas
const comparison = await migrationManager.compareSchemas()

console.log(`Differences: ${comparison.differences.length}`)
console.log(`Compatible: ${comparison.compatible}`)

// Sync schemas
const syncResult = await migrationManager.syncSchema({
  generateSQL: true,
  apply: true,
})
```

### Key Features

- **Bidirectional Migration**: SQLite ↔ PostgreSQL
- **Type Mapping**: Automatic type conversion with custom mappings
- **Value Transformation**: Boolean, array, JSON, and date conversions
- **Batch Processing**: Efficient large dataset migration
- **Parallel Migration**: Multi-table parallel processing
- **Progress Tracking**: Real-time migration progress
- **Schema Comparison**: Detect differences between databases
- **Sync SQL Generation**: Generate SQL for manual schema sync
- **Verification**: Automated migration verification

For detailed documentation, see [Migration Tools Guide](docs/migration-tools.md).

## Future Enhancements

Potential areas for expansion:

1. **Additional PostgreSQL Features**:
   - Table partitioning
   - Foreign data wrappers
   - Advanced indexing strategies
   - Custom aggregate functions

2. **Performance**:
   - Query result streaming
   - Prepared statement caching
   - Advanced connection pooling optimizations

## Conclusion

PostgreSQL support in NOORMME provides a production-ready database option while maintaining the same simple, intuitive API. You can start with SQLite and migrate to PostgreSQL when needed, without rewriting your application code.

The implementation follows NOORMME's core philosophy: **Zero-configuration, AI-ready, and production-grade.**

