import { promises as fs } from 'fs'
import * as path from 'path'
import chalk from 'chalk'
import { NOORMME } from '../../noormme.js'
import { TableInfo, ColumnInfo } from '../../types/index.js'

export async function generateTypes(options: {
  connection?: string
  output?: string
  format?: string
} = {}) {
  console.log(chalk.blue.bold('\n🔧 TypeScript Type Generation\n'))

  try {
    // Initialize NOORMME
    const db = options.connection ? new NOORMME(options.connection) : new NOORMME()
    await db.initialize()

    const schemaInfo = await db.getSchemaInfo()
    const outputPath = options.output || './types/database.d.ts'
    const format = options.format || 'typescript'

    let content: string
    switch (format) {
      case 'typescript':
        content = generateTypeScriptTypes(schemaInfo.tables)
        break
      case 'json':
        content = JSON.stringify(schemaInfo, null, 2)
        break
      default:
        throw new Error(`Unsupported format: ${format}`)
    }

    // Ensure directory exists
    await fs.mkdir(path.dirname(outputPath), { recursive: true })

    // Write the file
    await fs.writeFile(outputPath, content)

    console.log(chalk.green(`✅ Types generated: ${outputPath}`))
    console.log(chalk.gray(`Generated types for ${schemaInfo.tables.length} tables`))

    await db.close()

  } catch (error) {
    console.error(chalk.red('❌ Type generation failed:'), error instanceof Error ? error.message : error)
    process.exit(1)
  }
}

function generateTypeScriptTypes(tables: TableInfo[]): string {
  const interfaces = tables.map(table => generateTableInterface(table)).join('\n\n')

  const databaseInterface = `export interface Database {
${tables.map(t => `  ${t.name}: ${pascalCase(t.name)}Table;`).join('\n')}
}`

  return `// Auto-generated by NOORMME CLI
// Do not edit manually - regenerate with: npx noormme generate

${interfaces}

${databaseInterface}

// Repository types for each table
${tables.map(table => generateRepositoryType(table)).join('\n\n')}

// Export all table types
export type {
${tables.map(t => `  ${pascalCase(t.name)}Table,`).join('\n')}
${tables.map(t => `  ${pascalCase(t.name)}Insert,`).join('\n')}
${tables.map(t => `  ${pascalCase(t.name)}Update,`).join('\n')}
${tables.map(t => `  ${pascalCase(t.name)}Repository,`).join('\n')}
}
`
}

function generateTableInterface(table: TableInfo): string {
  const tableName = pascalCase(table.name)

  // Base table interface
  const baseInterface = `export interface ${tableName}Table {
${table.columns.map(col => generateColumnType(col)).join('\n')}
}`

  // Insert type (optional fields that have defaults or are auto-increment)
  const requiredFields = table.columns.filter(col =>
    !col.nullable &&
    !col.isAutoIncrement &&
    col.defaultValue === undefined &&
    !col.isPrimaryKey
  )
  const optionalFields = table.columns.filter(col =>
    col.nullable ||
    col.isAutoIncrement ||
    col.defaultValue !== undefined
  )

  const insertInterface = `export interface ${tableName}Insert {
${requiredFields.map(col => generateColumnType(col)).join('\n')}
${optionalFields.map(col => generateColumnType(col, true)).join('\n')}
}`

  // Update type (all fields optional except primary key)
  const updateInterface = `export interface ${tableName}Update {
${table.columns.map(col => generateColumnType(col, !col.isPrimaryKey)).join('\n')}
}`

  return `${baseInterface}

${insertInterface}

${updateInterface}`
}

function generateRepositoryType(table: TableInfo): string {
  const tableName = pascalCase(table.name)
  const primaryKeyType = getPrimaryKeyType(table)

  return `export interface ${tableName}Repository {
  findById(id: ${primaryKeyType}): Promise<${tableName}Table | null>;
  findAll(): Promise<${tableName}Table[]>;
  create(data: ${tableName}Insert): Promise<${tableName}Table>;
  update(entity: ${tableName}Update): Promise<${tableName}Table>;
  delete(id: ${primaryKeyType}): Promise<boolean>;
  count(): Promise<number>;
  exists(id: ${primaryKeyType}): Promise<boolean>;
  paginate(options: {
    page: number;
    limit: number;
    where?: Partial<${tableName}Table>;
    orderBy?: {
      column: keyof ${tableName}Table;
      direction: 'asc' | 'desc';
    };
  }): Promise<{
    data: ${tableName}Table[];
    pagination: {
      page: number;
      limit: number;
      total: number;
      totalPages: number;
      hasNext: boolean;
      hasPrev: boolean;
    };
  }>;
  withCount(id: ${primaryKeyType}, relationships: string[]): Promise<${tableName}Table & Record<string, number>>;
  // Dynamic finders
${table.columns.map(col => `  findBy${pascalCase(col.name)}(value: ${mapColumnToTsType(col)}): Promise<${tableName}Table | null>;`).join('\n')}
${table.columns.map(col => `  findManyBy${pascalCase(col.name)}(value: ${mapColumnToTsType(col)}): Promise<${tableName}Table[]>;`).join('\n')}
}`
}

function generateColumnType(column: ColumnInfo, optional = false): string {
  const name = column.name
  const type = mapColumnToTsType(column)
  const nullableType = column.nullable ? ` | null` : ''
  const optionalMark = optional ? '?' : ''

  return `  ${name}${optionalMark}: ${type}${nullableType};`
}

function mapColumnToTsType(column: ColumnInfo): string {
  const type = column.type.toLowerCase()

  // Integer types
  if (type.includes('int') || type.includes('serial') || type.includes('bigint')) {
    return 'number'
  }

  // Float types
  if (type.includes('float') || type.includes('double') || type.includes('decimal') || type.includes('numeric')) {
    return 'number'
  }

  // Boolean types
  if (type.includes('bool')) {
    return 'boolean'
  }

  // Date/time types
  if (type.includes('date') || type.includes('time') || type.includes('timestamp')) {
    return 'Date'
  }

  // JSON types
  if (type.includes('json')) {
    return 'Record<string, any>'
  }

  // Array types
  if (type.includes('array') || type.includes('[]')) {
    return 'any[]'
  }

  // UUID types
  if (type.includes('uuid')) {
    return 'string'
  }

  // Default to string for text types and unknowns
  return 'string'
}

function getPrimaryKeyType(table: TableInfo): string {
  if (!table.primaryKey || table.primaryKey.length === 0) {
    return 'any'
  }

  if (table.primaryKey.length === 1) {
    const pkColumn = table.columns.find(col => col.name === table.primaryKey![0])
    return pkColumn ? mapColumnToTsType(pkColumn) : 'any'
  }

  // Composite primary key
  const types = table.primaryKey.map(pkCol => {
    const column = table.columns.find(col => col.name === pkCol)
    return column ? mapColumnToTsType(column) : 'any'
  })

  return `[${types.join(', ')}]`
}

function pascalCase(str: string): string {
  return str
    .replace(/(?:^\w|[A-Z]|\b\w)/g, (word) => word.toUpperCase())
    .replace(/\s+/g, '')
    .replace(/[_-]/g, '')
}