import { describe, it } from 'mocha'
import { expect } from 'chai'
import { PostgresQueryCompiler } from '../../src/dialect/postgresql/postgresql-query-compiler.js'
import { ValueNode } from '../../src/operation-node/value-node.js'

/**
 * PostgreSQL Query Compiler Tests
 *
 * Tests PostgreSQL-specific SQL generation, including:
 * - Parameter placeholders ($1, $2, etc.)
 * - Identifier wrapping (double quotes)
 * - Auto-increment syntax (GENERATED AS IDENTITY)
 * - Boolean and null value handling
 */
describe('PostgreSQL Query Compiler Tests', () => {
  let compiler: PostgresQueryCompiler

  beforeEach(() => {
    compiler = new PostgresQueryCompiler()
  })

  describe('Parameter Placeholders', () => {
    it('should use $1, $2, $3 format for parameters', () => {
      // Access protected method for testing
      const getPlaceholder = (compiler as any).getCurrentParameterPlaceholder.bind(compiler)

      expect(getPlaceholder()).to.equal('$1')
      expect(getPlaceholder()).to.equal('$2')
      expect(getPlaceholder()).to.equal('$3')
    })

    it('should reset parameter counter for new compiler instance', () => {
      const compiler1 = new PostgresQueryCompiler()
      const compiler2 = new PostgresQueryCompiler()

      const getPlaceholder1 = (compiler1 as any).getCurrentParameterPlaceholder.bind(compiler1)
      const getPlaceholder2 = (compiler2 as any).getCurrentParameterPlaceholder.bind(compiler2)

      expect(getPlaceholder1()).to.equal('$1')
      expect(getPlaceholder2()).to.equal('$1')
    })

    it('should increment parameter counter sequentially', () => {
      const getPlaceholder = (compiler as any).getCurrentParameterPlaceholder.bind(compiler)

      for (let i = 1; i <= 10; i++) {
        expect(getPlaceholder()).to.equal(`$${i}`)
      }
    })
  })

  describe('Identifier Wrapping', () => {
    it('should use double quotes for identifiers', () => {
      const getLeftWrapper = (compiler as any).getLeftIdentifierWrapper.bind(compiler)
      const getRightWrapper = (compiler as any).getRightIdentifierWrapper.bind(compiler)

      expect(getLeftWrapper()).to.equal('"')
      expect(getRightWrapper()).to.equal('"')
    })

    it('should sanitize identifiers by escaping double quotes', () => {
      const sanitize = (compiler as any).sanitizeIdentifier.bind(compiler)

      expect(sanitize('normal_column')).to.equal('normal_column')
      expect(sanitize('column"with"quotes')).to.equal('column""with""quotes')
      expect(sanitize('"quoted"')).to.equal('""quoted""')
    })

    it('should handle empty string identifier', () => {
      const sanitize = (compiler as any).sanitizeIdentifier.bind(compiler)

      expect(sanitize('')).to.equal('')
    })

    it('should handle identifier with multiple consecutive quotes', () => {
      const sanitize = (compiler as any).sanitizeIdentifier.bind(compiler)

      expect(sanitize('test""value')).to.equal('test""""value')
    })
  })

  describe('Auto-Increment Syntax', () => {
    it('should return GENERATED AS IDENTITY for auto-increment', () => {
      const getAutoIncrement = (compiler as any).getAutoIncrement.bind(compiler)

      expect(getAutoIncrement()).to.equal('generated by default as identity')
    })
  })

  describe('Value Node Handling', () => {
    it('should handle null values', () => {
      const node: ValueNode = { kind: 'ValueNode', value: null }
      const visitValue = (compiler as any).visitValue.bind(compiler)

      // Mock append method to capture output
      let output = ''
      ;(compiler as any).append = (str: string) => { output += str }

      visitValue(node)
      expect(output).to.equal('null')
    })

    it('should handle undefined values as null', () => {
      const node: ValueNode = { kind: 'ValueNode', value: undefined }
      const visitValue = (compiler as any).visitValue.bind(compiler)

      let output = ''
      ;(compiler as any).append = (str: string) => { output += str }

      visitValue(node)
      expect(output).to.equal('null')
    })

    it('should handle boolean true', () => {
      const node: ValueNode = { kind: 'ValueNode', value: true }
      const visitValue = (compiler as any).visitValue.bind(compiler)

      let output = ''
      ;(compiler as any).append = (str: string) => { output += str }

      visitValue(node)
      expect(output).to.equal('true')
    })

    it('should handle boolean false', () => {
      const node: ValueNode = { kind: 'ValueNode', value: false }
      const visitValue = (compiler as any).visitValue.bind(compiler)

      let output = ''
      ;(compiler as any).append = (str: string) => { output += str }

      visitValue(node)
      expect(output).to.equal('false')
    })

    it('should use parent implementation for other value types', () => {
      const node: ValueNode = { kind: 'ValueNode', value: 'test' }
      const visitValue = (compiler as any).visitValue.bind(compiler)

      // Should call super.visitValue() for non-boolean/non-null values
      // We can't easily test this without mocking, but we can verify it doesn't throw
      let output = ''
      let parameterCalled = false
      ;(compiler as any).append = (str: string) => { output += str }
      ;(compiler as any).getCurrentParameterPlaceholder = () => {
        parameterCalled = true
        return '$1'
      }

      visitValue(node)

      // For non-boolean/non-null, it should use parameter placeholder
      expect(parameterCalled).to.be.true
    })
  })

  describe('Identifier Quoting', () => {
    it('should properly quote PostgreSQL keywords', () => {
      const sanitize = (compiler as any).sanitizeIdentifier.bind(compiler)

      // Test with common PostgreSQL keywords that need quoting
      const keywords = ['select', 'from', 'where', 'table', 'user', 'order']

      keywords.forEach(keyword => {
        // Should not modify the identifier itself, just escape quotes
        expect(sanitize(keyword)).to.equal(keyword)
      })
    })

    it('should handle schema-qualified identifiers', () => {
      const sanitize = (compiler as any).sanitizeIdentifier.bind(compiler)

      // Schema and table are typically handled separately
      expect(sanitize('public')).to.equal('public')
      expect(sanitize('my_schema')).to.equal('my_schema')
    })
  })

  describe('Edge Cases', () => {
    it('should handle very long identifiers', () => {
      const sanitize = (compiler as any).sanitizeIdentifier.bind(compiler)
      const longIdentifier = 'a'.repeat(100)

      expect(sanitize(longIdentifier)).to.equal(longIdentifier)
    })

    it('should handle identifiers with special characters', () => {
      const sanitize = (compiler as any).sanitizeIdentifier.bind(compiler)

      expect(sanitize('column_name')).to.equal('column_name')
      expect(sanitize('column-name')).to.equal('column-name')
      expect(sanitize('column.name')).to.equal('column.name')
    })

    it('should handle mixed case identifiers', () => {
      const sanitize = (compiler as any).sanitizeIdentifier.bind(compiler)

      expect(sanitize('CamelCase')).to.equal('CamelCase')
      expect(sanitize('UPPERCASE')).to.equal('UPPERCASE')
      expect(sanitize('lowercase')).to.equal('lowercase')
    })

    it('should handle Unicode identifiers', () => {
      const sanitize = (compiler as any).sanitizeIdentifier.bind(compiler)

      expect(sanitize('café')).to.equal('café')
      expect(sanitize('日本語')).to.equal('日本語')
      expect(sanitize('Привет')).to.equal('Привет')
    })
  })

  describe('Parameter Counter State', () => {
    it('should maintain parameter counter across multiple calls', () => {
      const getPlaceholder = (compiler as any).getCurrentParameterPlaceholder.bind(compiler)

      const placeholders = []
      for (let i = 0; i < 5; i++) {
        placeholders.push(getPlaceholder())
      }

      expect(placeholders).to.deep.equal(['$1', '$2', '$3', '$4', '$5'])
    })

    it('should not share state between compiler instances', () => {
      const compiler1 = new PostgresQueryCompiler()
      const compiler2 = new PostgresQueryCompiler()

      const getPlaceholder1 = (compiler1 as any).getCurrentParameterPlaceholder.bind(compiler1)
      const getPlaceholder2 = (compiler2 as any).getCurrentParameterPlaceholder.bind(compiler2)

      getPlaceholder1()
      getPlaceholder1()

      expect(getPlaceholder2()).to.equal('$1')
    })
  })

  describe('Integration Tests', () => {
    it('should handle complex value types correctly', () => {
      const testValues = [
        { value: null, expected: 'null' },
        { value: undefined, expected: 'null' },
        { value: true, expected: 'true' },
        { value: false, expected: 'false' },
      ]

      testValues.forEach(({ value, expected }) => {
        const testCompiler = new PostgresQueryCompiler()
        const node: ValueNode = { kind: 'ValueNode', value }

        let output = ''
        ;(testCompiler as any).append = (str: string) => { output += str }
        ;(testCompiler as any).visitValue(node)

        expect(output).to.equal(expected, `Failed for value: ${value}`)
      })
    })

    it('should generate correct SQL for boolean columns', () => {
      const testCompiler = new PostgresQueryCompiler()

      // Test true value
      const trueNode: ValueNode = { kind: 'ValueNode', value: true }
      let output = ''
      ;(testCompiler as any).append = (str: string) => { output += str }
      ;(testCompiler as any).visitValue(trueNode)

      expect(output).to.equal('true')

      // Test false value
      const falseNode: ValueNode = { kind: 'ValueNode', value: false }
      output = ''
      ;(testCompiler as any).append = (str: string) => { output += str }
      ;(testCompiler as any).visitValue(falseNode)

      expect(output).to.equal('false')
    })

    it('should properly escape identifiers in production scenarios', () => {
      const sanitize = (compiler as any).sanitizeIdentifier.bind(compiler)

      // Real-world scenarios
      const scenarios = [
        { input: 'user_email', expected: 'user_email' },
        { input: 'Email"Address', expected: 'Email""Address' },
        { input: '"already_quoted"', expected: '""already_quoted""' },
        { input: 'table"name"with"quotes', expected: 'table""name""with""quotes' },
      ]

      scenarios.forEach(({ input, expected }) => {
        expect(sanitize(input)).to.equal(expected, `Failed for input: ${input}`)
      })
    })
  })
})
